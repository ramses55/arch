\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
%\usepackage{lmodern}
\usepackage{amsmath}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{color}
\usepackage{subfiles}
\usepackage{float}




\usepackage[a4paper, total={6.3in,8in}]{geometry}


\title{Распознавание образов}

\date{}

\begin{document}

\maketitle

\section{Общие слова}

На изображении есть линейка, пакет с надписями и сама кость или несколько её фрагментов. Надо определить обуглена ли она, загрязнена ли, её размер. Считать надпись с пакета (qr код в том числе). Надо построить целый pipeline что, человек делает фото и загружает его, а система уже всё обрабатывает. Надо будет использовать OCR от YandexCloud.

\section{Идея решения}

Сейчас предлагается найти прямоугольную область внутри двух линеек (на одной картинке есть всего одна линейка, пока предлагается на неё забить).  В этой области будут кости и пакет. Пакет вроде успешно находится. Тогда остаётся область пакета залить белым цветом, а фрагменты костей просто выделить по цвету (буквально брать не белый цвет). Из полученной маски уже будет относительно легко получить все области. Эти области можно уже классифицировать на обугленный/ не обугленный, кость/зуб/ногть и так далее.

После надо узнать масштаб, чтобы определить размер фрагмента. Масштаб можно узнать по линейке или этикетке. Надо попробовать оба способа, хотя сейчас мне симпатичнее вариант с линейкой, так как на некоторых картинках пакет явно мятый и размер этикетки искажен.

На пакете нужно найти этикетку. Пока кажется, что это довольно легко сделать --- также выделить по цвету. Этикетку считать с помощью OCR и немного подправить текст. Заметим, что OCR плохо считывает надпись с самого пакета: иногда правильно, иногда частично правильно, а бывает вообще неправильно.


Последние этапы это определение обугленности, загрязненности и типа фрагмента. Здесь уже скорее всего придется использовать нейронную сеть --- ResNet для выделения признаков. Также наверное будет полезно в случае определения типа фрагмента добавлять к выделенным ResNet признакам размер фрагмента.


\section{Последовательность этапов}

Здесь записываются этапы решения задачи, выполненные этапы отмечаются.



\begin{enumerate}
	\item Найти на изображениях пакет коричневого цвета.
		\begin{enumerate}
			\item Найти этикетку на пакете 
			\item Считать этикетку с помощью OCR
		\end{enumerate}
	\item Найти первую линейку 
	\item Найти вторую линейку 
	\item Найти область между линейками без пакета и выделить по цвету фрагменты костей
	\item Найти масштаб и найти размер костей
	\item Передать вырезанные фрагменты костей на классификаторы и получить результат
\end{enumerate}



\section{Этапы}


\subsection{Нахождение пакета}

Сейчас надо попытаться найти пакет, ориентируясь на его цвет или форму. Есть проблема, что цвет пакета разнится от картинки к картинке, и на некоторых картинках есть области (например, участки стола) с примерно таким же цветом. Поэтому предлагается брать контур с максимальной площадью. Пока это вроде работает, хотя и в некоторых случаях часть кости попадает, потому что она находится в непосредственной близости к пакету. Результат --- прямоугольник с наименьшей площадью, который вмещает в себя выделенную область с максимальной площадью.


То есть сейчас алгоритм такой:


\begin{enumerate}
	\item Выделение маски по цвету с помощью cv2.inRange() (после блюр 21$\times$21, алгоритм чувствителен к этому параметру)
	\item Нахождение конутров маски
	\item Выбор контура с наибольшей площадью
	\item Подгон прямоугольника с наименьшей площадью под эту область с помощью minAreaRect
	\item Специальная функция вырезает получившийся прямоугольник из картинки (функция нужна, потому что прямоугольник может быть наклонен) 
\end{enumerate}


\subsection{Нахождение линейки}
Линейку можно найти с помощью выделения признаков (например SIFT) и гомографии. На сайте opencv есть конкретный пример как это делать. Такой подход позволяет легко посчитать и масштаб.

В итоге последовательность действий такая:

\begin{enumerate}
	\item Поиск keypoints и descriptors с помощью cv2.sift.detectAndCompute
	\item Поиск линейки
	\item Нахождение масштаба
	\item Удаление keypoints и descriptors уже использованных для поиска первой линейки
	\item Поиск линейки
	\item Определение области между двумя линейками
\end{enumerate}


\subsection{Поиск фрагментов кости}
В области между линейками и с удаленным пакетом ищутся фрагменты костей по цвету. Пока не всегда получается их хорошо выделить, так как цвет некоторых фрагментов уж очень схож с цветом фона. По сути он ближе к белому чем к коричневому или серому --- обычному цвету фрагментов. Возможно это можно решить закрашиванием областей не в белый цвет, а черный. Тогда надо будет фильтровать уже с другой стороны. Но обязательно надо сигнализировать, что не удалось найти фрагмент кости.


\end{document}
